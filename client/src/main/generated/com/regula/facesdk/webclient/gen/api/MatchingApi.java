/*
 * Regula Face SDK Web API
 * <a href=\"https://regulaforensics.com/products/face-recognition-sdk/  \" target=\"_blank\">Regula Face SDK</a> is a cross-platform biometric verification solution for a digital identity verification process and image quality assurance. The SDK enables convenient and reliable face capture on the client side (mobile, web, and desktop) and further processing on the client or server side.   The Face SDK includes the following features:  * <a href=\"https://docs.regulaforensics.com/develop/face-sdk/overview/introduction/#face-detection\" target=\"_blank\">Face detection and image quality assessment</a> * <a href=\"https://docs.regulaforensics.com/develop/face-sdk/overview/introduction/#face-comparison-11\" target=\"_blank\">Face match (1:1)</a> * <a href=\"https://docs.regulaforensics.com/develop/face-sdk/overview/introduction/#face-identification-1n\" target=\"_blank\">Face search (1:N)</a> * <a href=\"https://docs.regulaforensics.com/develop/face-sdk/overview/introduction/#liveness-assessment\" target=\"_blank\">Liveness detection</a>  Here is the <a href=\"https://github.com/regulaforensics/FaceSDK-web-openapi  \" target=\"_blank\">OpenAPI specification on GitHub</a>.   ### Clients * [JavaScript](https://github.com/regulaforensics/FaceSDK-web-js-client) client for the browser and node.js based on axios * [Java](https://github.com/regulaforensics/FaceSDK-web-java-client) client compatible with jvm and android * [Python](https://github.com/regulaforensics/FaceSDK-web-python-client) 3.5+ client * [C#](https://github.com/regulaforensics/FaceSDK-web-csharp-client) client for .NET & .NET Core 
 *
 * The version of the OpenAPI document: 6.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.regula.facesdk.webclient.gen.api;

import com.regula.facesdk.webclient.ApiCallback;
import com.regula.facesdk.webclient.ApiClient;
import com.regula.facesdk.webclient.ApiException;
import com.regula.facesdk.webclient.ApiResponse;
import com.regula.facesdk.webclient.Configuration;
import com.regula.facesdk.webclient.Pair;
import com.regula.facesdk.webclient.ProgressRequestBody;
import com.regula.facesdk.webclient.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.regula.facesdk.webclient.gen.model.DetectRequest;
import com.regula.facesdk.webclient.gen.model.DetectResponse;
import com.regula.facesdk.webclient.gen.model.MatchAndSearchRequest;
import com.regula.facesdk.webclient.gen.model.MatchAndSearchResponse;
import com.regula.facesdk.webclient.gen.model.MatchRequest;
import com.regula.facesdk.webclient.gen.model.MatchResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MatchingApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public MatchingApi() {
        this(Configuration.getDefaultApiClient());
    }

    public MatchingApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for detect
     * @param detectRequest  (required)
     * @param xRequestID Request header label. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation; the coordinates of the detected faces are returned. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Bad license. Either the server or request does not contain a valid license. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call detectCall(DetectRequest detectRequest, String xRequestID, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = detectRequest;

        // create path and map variables
        String localVarPath = "/api/detect";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xRequestID != null) {
            localVarHeaderParams.put("X-RequestID", localVarApiClient.parameterToString(xRequestID));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call detectValidateBeforeCall(DetectRequest detectRequest, String xRequestID, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'detectRequest' is set
        if (detectRequest == null) {
            throw new ApiException("Missing the required parameter 'detectRequest' when calling detect(Async)");
        }
        

        okhttp3.Call localVarCall = detectCall(detectRequest, xRequestID, _callback);
        return localVarCall;

    }

    /**
     * detect and check quality
     * Use the POST &#x60;api/detect&#x60; endpoint to analyze images, recognize faces in them, and return cropped and aligned portraits of the detected people.  The Face Detection feature lets you: - **Check face image quality**: Assess whether a portrait meets certain standards, for example, ICAO, Schengen visa, USA visa. To perform image quality check, use the &#x60;processParam.quality&#x60; field. - **Evaluate face attributes**: Estimate the age range of a person; check whether the eyes are occluded, closed, or open; detect a facial expression or smile; see if there are glasses, sunglasses, head coverage, medical mask, etc. To evaluate attributes, add the &#x60;processParam.attributes&#x60; field.  You can perform Face Detection in two ways: - By adding parameters manually. In this case, the configuration is not saved and can not be automatically repeated. - By a processing &#x60;scenario&#x60; that includes certain parameters. You can use predefined scenarios or add custom ones.
     * @param detectRequest  (required)
     * @param xRequestID Request header label. (optional)
     * @return DetectResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation; the coordinates of the detected faces are returned. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Bad license. Either the server or request does not contain a valid license. </td><td>  -  </td></tr>
     </table>
     */
    public DetectResponse detect(DetectRequest detectRequest, String xRequestID) throws ApiException {
        ApiResponse<DetectResponse> localVarResp = detectWithHttpInfo(detectRequest, xRequestID);
        return localVarResp.getData();
    }

    /**
     * detect and check quality
     * Use the POST &#x60;api/detect&#x60; endpoint to analyze images, recognize faces in them, and return cropped and aligned portraits of the detected people.  The Face Detection feature lets you: - **Check face image quality**: Assess whether a portrait meets certain standards, for example, ICAO, Schengen visa, USA visa. To perform image quality check, use the &#x60;processParam.quality&#x60; field. - **Evaluate face attributes**: Estimate the age range of a person; check whether the eyes are occluded, closed, or open; detect a facial expression or smile; see if there are glasses, sunglasses, head coverage, medical mask, etc. To evaluate attributes, add the &#x60;processParam.attributes&#x60; field.  You can perform Face Detection in two ways: - By adding parameters manually. In this case, the configuration is not saved and can not be automatically repeated. - By a processing &#x60;scenario&#x60; that includes certain parameters. You can use predefined scenarios or add custom ones.
     * @param detectRequest  (required)
     * @param xRequestID Request header label. (optional)
     * @return ApiResponse&lt;DetectResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation; the coordinates of the detected faces are returned. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Bad license. Either the server or request does not contain a valid license. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DetectResponse> detectWithHttpInfo(DetectRequest detectRequest, String xRequestID) throws ApiException {
        okhttp3.Call localVarCall = detectValidateBeforeCall(detectRequest, xRequestID, null);
        Type localVarReturnType = new TypeToken<DetectResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * detect and check quality (asynchronously)
     * Use the POST &#x60;api/detect&#x60; endpoint to analyze images, recognize faces in them, and return cropped and aligned portraits of the detected people.  The Face Detection feature lets you: - **Check face image quality**: Assess whether a portrait meets certain standards, for example, ICAO, Schengen visa, USA visa. To perform image quality check, use the &#x60;processParam.quality&#x60; field. - **Evaluate face attributes**: Estimate the age range of a person; check whether the eyes are occluded, closed, or open; detect a facial expression or smile; see if there are glasses, sunglasses, head coverage, medical mask, etc. To evaluate attributes, add the &#x60;processParam.attributes&#x60; field.  You can perform Face Detection in two ways: - By adding parameters manually. In this case, the configuration is not saved and can not be automatically repeated. - By a processing &#x60;scenario&#x60; that includes certain parameters. You can use predefined scenarios or add custom ones.
     * @param detectRequest  (required)
     * @param xRequestID Request header label. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation; the coordinates of the detected faces are returned. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Bad license. Either the server or request does not contain a valid license. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call detectAsync(DetectRequest detectRequest, String xRequestID, final ApiCallback<DetectResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = detectValidateBeforeCall(detectRequest, xRequestID, _callback);
        Type localVarReturnType = new TypeToken<DetectResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for match
     * @param matchRequest  (required)
     * @param xRequestID Request header label. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation; the compare results are returned. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Bad license. Either the server or request does not contain a valid license. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call matchCall(MatchRequest matchRequest, String xRequestID, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = matchRequest;

        // create path and map variables
        String localVarPath = "/api/match";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xRequestID != null) {
            localVarHeaderParams.put("X-RequestID", localVarApiClient.parameterToString(xRequestID));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call matchValidateBeforeCall(MatchRequest matchRequest, String xRequestID, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'matchRequest' is set
        if (matchRequest == null) {
            throw new ApiException("Missing the required parameter 'matchRequest' when calling match(Async)");
        }
        

        okhttp3.Call localVarCall = matchCall(matchRequest, xRequestID, _callback);
        return localVarCall;

    }

    /**
     * compare faces (1:1)
     * To perform a comparison of faces in the same image or in two different images, use POST &#x60;/api/match&#x60;. It&#39;s possible to compare faces in the same image or in two different images, this is defined by the &#x60;images.type&#x60; parameter. &lt;br&gt;&lt;br&gt; The face detection result is displayed in the &#x60;detections&#x60; field. Each face is identified by two parameters: &#x60;faceIndex&#x60; (the index number of the face) and &#x60;imageIndex&#x60; (the index number of the image on which the face is detected). So, if there are two images each of which has two faces in them, the parameters will be the following: - First face in the first image: &#x60;faceIndex: 0&#x60;, &#x60;imageIndex: 0&#x60; - Second face in the first image: &#x60;faceIndex: 1&#x60;, &#x60;imageIndex: 0&#x60; - First face of the second image: &#x60;faceIndex: 0&#x60;, &#x60;imageIndex: 1&#x60; - Second face in the second image: &#x60;faceIndex: 1&#x60;, &#x60;imageIndex: 1&#x60;
     * @param matchRequest  (required)
     * @param xRequestID Request header label. (optional)
     * @return MatchResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation; the compare results are returned. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Bad license. Either the server or request does not contain a valid license. </td><td>  -  </td></tr>
     </table>
     */
    public MatchResponse match(MatchRequest matchRequest, String xRequestID) throws ApiException {
        ApiResponse<MatchResponse> localVarResp = matchWithHttpInfo(matchRequest, xRequestID);
        return localVarResp.getData();
    }

    /**
     * compare faces (1:1)
     * To perform a comparison of faces in the same image or in two different images, use POST &#x60;/api/match&#x60;. It&#39;s possible to compare faces in the same image or in two different images, this is defined by the &#x60;images.type&#x60; parameter. &lt;br&gt;&lt;br&gt; The face detection result is displayed in the &#x60;detections&#x60; field. Each face is identified by two parameters: &#x60;faceIndex&#x60; (the index number of the face) and &#x60;imageIndex&#x60; (the index number of the image on which the face is detected). So, if there are two images each of which has two faces in them, the parameters will be the following: - First face in the first image: &#x60;faceIndex: 0&#x60;, &#x60;imageIndex: 0&#x60; - Second face in the first image: &#x60;faceIndex: 1&#x60;, &#x60;imageIndex: 0&#x60; - First face of the second image: &#x60;faceIndex: 0&#x60;, &#x60;imageIndex: 1&#x60; - Second face in the second image: &#x60;faceIndex: 1&#x60;, &#x60;imageIndex: 1&#x60;
     * @param matchRequest  (required)
     * @param xRequestID Request header label. (optional)
     * @return ApiResponse&lt;MatchResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation; the compare results are returned. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Bad license. Either the server or request does not contain a valid license. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MatchResponse> matchWithHttpInfo(MatchRequest matchRequest, String xRequestID) throws ApiException {
        okhttp3.Call localVarCall = matchValidateBeforeCall(matchRequest, xRequestID, null);
        Type localVarReturnType = new TypeToken<MatchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * compare faces (1:1) (asynchronously)
     * To perform a comparison of faces in the same image or in two different images, use POST &#x60;/api/match&#x60;. It&#39;s possible to compare faces in the same image or in two different images, this is defined by the &#x60;images.type&#x60; parameter. &lt;br&gt;&lt;br&gt; The face detection result is displayed in the &#x60;detections&#x60; field. Each face is identified by two parameters: &#x60;faceIndex&#x60; (the index number of the face) and &#x60;imageIndex&#x60; (the index number of the image on which the face is detected). So, if there are two images each of which has two faces in them, the parameters will be the following: - First face in the first image: &#x60;faceIndex: 0&#x60;, &#x60;imageIndex: 0&#x60; - Second face in the first image: &#x60;faceIndex: 1&#x60;, &#x60;imageIndex: 0&#x60; - First face of the second image: &#x60;faceIndex: 0&#x60;, &#x60;imageIndex: 1&#x60; - Second face in the second image: &#x60;faceIndex: 1&#x60;, &#x60;imageIndex: 1&#x60;
     * @param matchRequest  (required)
     * @param xRequestID Request header label. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation; the compare results are returned. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Bad license. Either the server or request does not contain a valid license. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call matchAsync(MatchRequest matchRequest, String xRequestID, final ApiCallback<MatchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = matchValidateBeforeCall(matchRequest, xRequestID, _callback);
        Type localVarReturnType = new TypeToken<MatchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for matchAndSearch
     * @param matchAndSearchRequest  (required)
     * @param xRequestID Request header label. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation; the compare results are returned. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Bad license. Either the server or request does not contain a valid license. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call matchAndSearchCall(MatchAndSearchRequest matchAndSearchRequest, String xRequestID, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = matchAndSearchRequest;

        // create path and map variables
        String localVarPath = "/api/match_and_search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xRequestID != null) {
            localVarHeaderParams.put("X-RequestID", localVarApiClient.parameterToString(xRequestID));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call matchAndSearchValidateBeforeCall(MatchAndSearchRequest matchAndSearchRequest, String xRequestID, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'matchAndSearchRequest' is set
        if (matchAndSearchRequest == null) {
            throw new ApiException("Missing the required parameter 'matchAndSearchRequest' when calling matchAndSearch(Async)");
        }
        

        okhttp3.Call localVarCall = matchAndSearchCall(matchAndSearchRequest, xRequestID, _callback);
        return localVarCall;

    }

    /**
     * match and search (1:1 + 1:N)
     * To compare several images from a document and look up a person in the database in one request, use POST &#x60;/api/match_and_search&#x60;. In this case, the calculation of the descriptor will be performed only once, as opposed to using two requests for the same operation. If only one person is identified, matching is not performed and only search is carried out.
     * @param matchAndSearchRequest  (required)
     * @param xRequestID Request header label. (optional)
     * @return MatchAndSearchResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation; the compare results are returned. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Bad license. Either the server or request does not contain a valid license. </td><td>  -  </td></tr>
     </table>
     */
    public MatchAndSearchResponse matchAndSearch(MatchAndSearchRequest matchAndSearchRequest, String xRequestID) throws ApiException {
        ApiResponse<MatchAndSearchResponse> localVarResp = matchAndSearchWithHttpInfo(matchAndSearchRequest, xRequestID);
        return localVarResp.getData();
    }

    /**
     * match and search (1:1 + 1:N)
     * To compare several images from a document and look up a person in the database in one request, use POST &#x60;/api/match_and_search&#x60;. In this case, the calculation of the descriptor will be performed only once, as opposed to using two requests for the same operation. If only one person is identified, matching is not performed and only search is carried out.
     * @param matchAndSearchRequest  (required)
     * @param xRequestID Request header label. (optional)
     * @return ApiResponse&lt;MatchAndSearchResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation; the compare results are returned. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Bad license. Either the server or request does not contain a valid license. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MatchAndSearchResponse> matchAndSearchWithHttpInfo(MatchAndSearchRequest matchAndSearchRequest, String xRequestID) throws ApiException {
        okhttp3.Call localVarCall = matchAndSearchValidateBeforeCall(matchAndSearchRequest, xRequestID, null);
        Type localVarReturnType = new TypeToken<MatchAndSearchResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * match and search (1:1 + 1:N) (asynchronously)
     * To compare several images from a document and look up a person in the database in one request, use POST &#x60;/api/match_and_search&#x60;. In this case, the calculation of the descriptor will be performed only once, as opposed to using two requests for the same operation. If only one person is identified, matching is not performed and only search is carried out.
     * @param matchAndSearchRequest  (required)
     * @param xRequestID Request header label. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful operation; the compare results are returned. </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Bad license. Either the server or request does not contain a valid license. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call matchAndSearchAsync(MatchAndSearchRequest matchAndSearchRequest, String xRequestID, final ApiCallback<MatchAndSearchResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = matchAndSearchValidateBeforeCall(matchAndSearchRequest, xRequestID, _callback);
        Type localVarReturnType = new TypeToken<MatchAndSearchResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
